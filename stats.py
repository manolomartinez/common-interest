# Copyright (C) 2013  Manolo Mart√≠nez <manolomartinez@ub.edu>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import commoninterest as ci
import json
import pickle
import time


def files_to_json(filenamelist, outputjson): # From many json files to one
    games = {}
    for filename in filenamelist:
        print(filename)
        with open(filename, 'r') as fileobject:
            jsfl = json.load(fileobject)
            dictio = {list(item)[0]:item[list(item)[0]] for item in jsfl}
            games.update(dictio)
    with open(outputjson, 'w') as outputfile:
        json.dump(games, outputfile)
        
def dedupe(jsonfile, outputjson): # Remove duplicates from json file
    newjson = {}
    with open(jsonfile, 'r') as fileobject:
        ds = json.load(fileobject) #this contains the json
        for key in ds:
            if key not in newjson:
                newjson[key] = ds[key]
    with open(outputjson, 'w') as outputfile:
        json.dump(newjson, outputfile)


def proportion(jsonfile): # This takes a bunch of games generated by the
    # manygames module and calculates the proportion of games with info-using
    # equilibria, and the maximum information transferred for a certain value
    # of c (c*)
    games = {}
    with open(jsonfile, 'r') as fileobject:
        games.update(json.load(fileobject))
    timestr = time.strftime("%d%b%H-%M")
    datapointsname = ''.join(["proportion", timestr, ".csv"])
    #dictio = {list(item)[0]:item[list(item)[0]] for item in games}
    kendalldict = {}
    for key in games:
        payoffs = eval(key)
        game = ci.Game(payoffs)
        kendall = game.c # the value of kendall will be different if we
        # are preparing the data for Figure 1 or for Figure ...
        sinfos, rinfos, jinfos = game.calculate_info_content(games[key])
        if not kendall in kendalldict:
            kendalldict[kendall] = [0,0,[]]
        kendalldict[kendall][0] += 1
        if any([jinfo > 10e-4 for
                jinfo in jinfos]):
            kendalldict[kendall][1] += 1
        try:
            kendalldict[kendall][2].append(max(jinfos))
        except ValueError:
            pass
    print(len(games))
    with open(datapointsname, 'w') as datapoints:
        for key in sorted(kendalldict):
            proportion = kendalldict[key][1]/kendalldict[key][0]
            champion  = max(kendalldict[key][2])
            datapoints.write("{} {} {} {}\n".format(key, proportion, champion,
                kendalldict[key][0]))
        

def withintra(picklefile):  # Taking into account intra-Kendalls
    # Here I'm using pickled files. Using json files instead is trivial
    #games = {}
    with open(picklefile, 'rb') as fileobject:
        #games.update(json.load(fileobject))
        games = pickle.load(fileobject)
    timestr = time.strftime("%d%b%H-%M")
    datapointsnamereceiver = ''.join(["withintrareceiver", timestr, ".csv"])
    kendalldictreceiver = {}
    intrakendallsreceiver = []
    kendalls = []
    with open(datapointsnamereceiver, 'w') as datapointsreceiver:
        for pair in games:
            print(pair)
            for gamedata in games[pair]:
                key = list(gamedata.keys())[0]
                payoffs = eval(key)
                game = ci.Game(payoffs)
                kendall = game.kendalldistance
                kendallreceiver = game.kr
                if kendall not in kendalls:
                    kendalls.append(kendall)
                if kendallreceiver not in intrakendallsreceiver:
                    intrakendallsreceiver.append(kendallreceiver)
                sinfos, rinfos, jinfos = game.calculate_info_content(gamedata[key])
                duoreceiver = str([kendall, kendallreceiver])
                if not duoreceiver in kendalldictreceiver:
                    kendalldictreceiver[duoreceiver] = [0, 0, []]
                kendalldictreceiver[duoreceiver][0] += 1
                try:
                    if max(jinfos) > 10e-4:
                        kendalldictreceiver[duoreceiver][1] += 1
                    kendalldictreceiver[duoreceiver][2].append(max(jinfos))
                except ValueError:
                    kendalldictreceiver[duoreceiver][2].append(0)
        totalgames = []
        for key in sorted(kendalldictreceiver):
            proportion = kendalldictreceiver[
                key][1]/kendalldictreceiver[key][0]
            values = eval(key)
            datapointsreceiver.write(
                "{} {} {} {} {} {}\n".format(values[0], values[1],
                kendalldictreceiver[key][1], kendalldictreceiver[key][0],
                proportion, max(kendalldictreceiver[key][2])))
